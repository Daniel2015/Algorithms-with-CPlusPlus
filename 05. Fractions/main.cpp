/*
На Любо му станало скучно от всички тези домашни и решил да играе на
следната игра – измислял си едно цяло число N и след това нареждал по
големина всички правилни дроби по големина. (правила дроб – числителят е
по-малък от знаменателя и дробта е несъкратима) Числителят и знаменателят
на правилната дроб трябва да са по-малки или равни на N. В получената
редица не трябва да има повторения. Скоро обаче Любо изпаднал в
затруднение и вече не му било толкова интересно да нарежда дробите. Затова
той се обърнал към вас с молбата да му напишете програма, която да прави
това за него.
Вход
На единствен ред има едно число N.
Изход
На единствен ред се иска редицата от всички правилни дроби разделени с
интервал, като една правилна дроб се записва във вида числител/знаменател.
0-та се записва само като 0, а не 0/1.
Ограничения
1 <= N <= 100
*/
#include <iostream>
#include <stdio.h>

using namespace std;

bool euclid(int x, int y) {
    int t = x % y;
    while (t != 0) {
        x = y;
        y = t;
        t = x % y;
    }
    return y == 1;
}

int main()
{
    int n;
    int counter = 0;
    scanf("%d", &n);
    int holder[100000][2];
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (euclid(j, i)) {
                holder[counter][0] = j;
                holder[counter][1] = i;
                ++counter;
            }
        }
    }

    for(int i=0; i<counter;i++){
        for(int j=0; j< counter-1; j++){
            if(holder[j][0]*holder[j+1][1]>holder[j][1]*holder[j+1][0]){
                int t=holder[j][0], q=holder[j][1];
                holder[j][0]=holder[j+1][0];
                holder[j][1]=holder[j+1][1];
                holder[j+1][0]=t;
                holder[j+1][1]=q;
            }
        }
    }
    for (int k = 0; k < counter; k++) {
        if(holder[k][0]==0){
            printf("0 ");
        }
        else{
            printf("%d/%d ",holder[k][0], holder[k][1]);
        }
    }
    return 0;
}
